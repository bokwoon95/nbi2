(() => {
  // static/basecoat.js
  (() => {
    const componentRegistry = {};
    let observer2 = null;
    const registerComponent = (name, selector2, initFunction) => {
      componentRegistry[name] = {
        selector: selector2,
        init: initFunction
      };
    };
    const initComponent = (element, componentName) => {
      const component = componentRegistry[componentName];
      if (!component) return;
      try {
        component.init(element);
      } catch (error) {
        console.error(`Failed to initialize ${componentName}:`, error);
      }
    };
    const initAllComponents = () => {
      Object.entries(componentRegistry).forEach(([name, { selector: selector2, init }]) => {
        document.querySelectorAll(selector2).forEach(init);
      });
    };
    const initNewComponents = (node) => {
      if (node.nodeType !== Node.ELEMENT_NODE) return;
      Object.entries(componentRegistry).forEach(([name, { selector: selector2, init }]) => {
        if (node.matches(selector2)) {
          init(node);
        }
        node.querySelectorAll(selector2).forEach(init);
      });
    };
    const startObserver = () => {
      if (observer2) return;
      observer2 = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach(initNewComponents);
        });
      });
      observer2.observe(document.body, { childList: true, subtree: true });
    };
    const stopObserver = () => {
      if (observer2) {
        observer2.disconnect();
        observer2 = null;
      }
    };
    const reinitComponent = (componentName) => {
      const component = componentRegistry[componentName];
      if (!component) {
        console.warn(`Component '${componentName}' not found in registry`);
        return;
      }
      const flag = `data-${componentName}-initialized`;
      document.querySelectorAll(`[${flag}]`).forEach((el) => {
        el.removeAttribute(flag);
      });
      document.querySelectorAll(component.selector).forEach(component.init);
    };
    const reinitAll = () => {
      Object.entries(componentRegistry).forEach(([name, { selector: selector2 }]) => {
        const flag = `data-${name}-initialized`;
        document.querySelectorAll(`[${flag}]`).forEach((el) => {
          el.removeAttribute(flag);
        });
      });
      initAllComponents();
    };
    window.basecoat = {
      register: registerComponent,
      init: reinitComponent,
      initAll: reinitAll,
      start: startObserver,
      stop: stopObserver
    };
    document.addEventListener("DOMContentLoaded", () => {
      initAllComponents();
      startObserver();
    });
  })();

  // static/sidebar.js
  (() => {
    if (!window.history.__basecoatPatched) {
      const originalPushState = window.history.pushState;
      window.history.pushState = function(...args) {
        originalPushState.apply(this, args);
        window.dispatchEvent(new Event("basecoat:locationchange"));
      };
      const originalReplaceState = window.history.replaceState;
      window.history.replaceState = function(...args) {
        originalReplaceState.apply(this, args);
        window.dispatchEvent(new Event("basecoat:locationchange"));
      };
      window.history.__basecoatPatched = true;
    }
    const initSidebar = (sidebarComponent) => {
      const initialOpen = sidebarComponent.dataset.initialOpen !== "false";
      const initialMobileOpen = sidebarComponent.dataset.initialMobileOpen === "true";
      const breakpoint = parseInt(sidebarComponent.dataset.breakpoint) || 768;
      let open = breakpoint > 0 ? window.innerWidth >= breakpoint ? initialOpen : initialMobileOpen : initialOpen;
      const updateCurrentPageLinks = () => {
        const currentPath = window.location.pathname.replace(/\/$/, "");
        sidebarComponent.querySelectorAll("a").forEach((link) => {
          if (link.hasAttribute("data-ignore-current")) return;
          const linkPath = new URL(link.href).pathname.replace(/\/$/, "");
          if (linkPath === currentPath) {
            link.setAttribute("aria-current", "page");
          } else {
            link.removeAttribute("aria-current");
          }
        });
      };
      const updateState = () => {
        sidebarComponent.setAttribute("aria-hidden", !open);
        if (open) {
          sidebarComponent.removeAttribute("inert");
        } else {
          sidebarComponent.setAttribute("inert", "");
        }
      };
      const setState = (state) => {
        open = state;
        updateState();
      };
      const sidebarId = sidebarComponent.id;
      document.addEventListener("basecoat:sidebar", (event) => {
        if (event.detail?.id && event.detail.id !== sidebarId) return;
        switch (event.detail?.action) {
          case "open":
            setState(true);
            break;
          case "close":
            setState(false);
            break;
          default:
            setState(!open);
            break;
        }
      });
      sidebarComponent.addEventListener("click", (event) => {
        const target = event.target;
        const nav = sidebarComponent.querySelector("nav");
        const isMobile = window.innerWidth < breakpoint;
        if (isMobile && (target.closest("a, button") && !target.closest("[data-keep-mobile-sidebar-open]"))) {
          if (document.activeElement) document.activeElement.blur();
          setState(false);
          return;
        }
        if (target === sidebarComponent || nav && !nav.contains(target)) {
          if (document.activeElement) document.activeElement.blur();
          setState(false);
        }
      });
      window.addEventListener("popstate", updateCurrentPageLinks);
      window.addEventListener("basecoat:locationchange", updateCurrentPageLinks);
      updateState();
      updateCurrentPageLinks();
      sidebarComponent.dataset.sidebarInitialized = true;
      sidebarComponent.dispatchEvent(new CustomEvent("basecoat:initialized"));
    };
    if (window.basecoat) {
      window.basecoat.register("sidebar", ".sidebar:not([data-sidebar-initialized])", initSidebar);
    }
  })();

  // static/dropdown-menu-v4.js
  (() => {
    const initDropdownMenu = (dropdownMenuComponent) => {
      const trigger = dropdownMenuComponent.querySelector(":scope > button");
      const popover = dropdownMenuComponent.querySelector(":scope > [data-popover]");
      const menu = popover?.querySelector('[role="menu"]');
      const supportsManualPopover = typeof popover?.showPopover === "function" && typeof popover?.hidePopover === "function";
      if (supportsManualPopover) {
        popover.setAttribute("popover", "manual");
        popover.style.position = "fixed";
        popover.style.inset = "auto";
        popover.style.transform = "none";
      }
      if (!trigger || !menu || !popover) {
        const missing = [];
        if (!trigger) missing.push("trigger");
        if (!menu) missing.push("menu");
        if (!popover) missing.push("popover");
        console.error(`Dropdown menu initialisation failed. Missing element(s): ${missing.join(", ")}`, dropdownMenuComponent);
        return;
      }
      let positionFrame = 0;
      let menuItems = [];
      let activeIndex = -1;
      const isMobileLike = () => window.matchMedia("(hover: none), (pointer: coarse)").matches;
      const submenuParents = () => Array.from(menu.querySelectorAll('[role="menuitem"][aria-haspopup="menu"]'));
      const closeAllSubmenus = () => {
        submenuParents().forEach((parent) => {
          const submenu = parent.querySelector(':scope > [role="menu"]');
          parent.setAttribute("aria-expanded", "false");
          submenu?.setAttribute("aria-hidden", "true");
        });
      };
      const openSubmenu = (parent) => {
        const submenu = parent.querySelector(':scope > [role="menu"]');
        if (!submenu) return;
        closeAllSubmenus();
        parent.setAttribute("aria-expanded", "true");
        submenu.setAttribute("aria-hidden", "false");
      };
      const setActiveItem = (index) => {
        if (activeIndex > -1 && menuItems[activeIndex]) {
          menuItems[activeIndex].classList.remove("active");
        }
        activeIndex = index;
        if (activeIndex > -1 && menuItems[activeIndex]) {
          const activeItem = menuItems[activeIndex];
          activeItem.classList.add("active");
          if (activeItem.id) trigger.setAttribute("aria-activedescendant", activeItem.id);
          else trigger.removeAttribute("aria-activedescendant");
        } else {
          trigger.removeAttribute("aria-activedescendant");
        }
      };
      const closePopover = (focusOnTrigger = true) => {
        if (trigger.getAttribute("aria-expanded") === "false") return;
        trigger.setAttribute("aria-expanded", "false");
        trigger.removeAttribute("aria-activedescendant");
        popover.setAttribute("aria-hidden", "true");
        if (supportsManualPopover && popover.matches(":popover-open")) popover.hidePopover();
        closeAllSubmenus();
        if (focusOnTrigger) trigger.focus();
        if (supportsManualPopover) cancelAnimationFrame(positionFrame);
        setActiveItem(-1);
      };
      const updatePosition = () => {
        if (!supportsManualPopover || trigger.getAttribute("aria-expanded") !== "true") return;
        const rect = trigger.getBoundingClientRect();
        const visualViewport = window.visualViewport;
        const viewportLeft = visualViewport ? visualViewport.offsetLeft : 0;
        const viewportTop = visualViewport ? visualViewport.offsetTop : 0;
        const viewportWidth = visualViewport ? visualViewport.width : window.innerWidth;
        const viewportHeight = visualViewport ? visualViewport.height : window.innerHeight;
        const minLeft = viewportLeft + 8;
        const minTop = viewportTop + 8;
        const maxLeft = viewportLeft + viewportWidth - 8;
        const maxTop = viewportTop + viewportHeight - 8;
        let left = rect.left + viewportLeft;
        let top = rect.bottom + viewportTop;
        const width = popover.offsetWidth;
        const height = popover.offsetHeight;
        if (left + width > maxLeft) left = Math.max(minLeft, maxLeft - width);
        if (left < minLeft) left = minLeft;
        if (top + height > maxTop) {
          const aboveTop = rect.top + viewportTop - height;
          const spaceBelow = maxTop - (rect.bottom + viewportTop);
          const spaceAbove = rect.top + viewportTop - minTop;
          if (aboveTop >= minTop || spaceAbove > spaceBelow) top = aboveTop;
          else top = Math.max(minTop, maxTop - height);
        }
        if (top < minTop) top = minTop;
        popover.style.left = `${Math.round(left)}px`;
        popover.style.top = `${Math.round(top)}px`;
      };
      const openPopover = (initialSelection = false) => {
        document.dispatchEvent(new CustomEvent("basecoat:popover", { detail: { source: dropdownMenuComponent } }));
        trigger.setAttribute("aria-expanded", "true");
        popover.setAttribute("aria-hidden", "false");
        if (supportsManualPopover) {
          popover.showPopover();
          updatePosition();
          const tick = () => {
            if (trigger.getAttribute("aria-expanded") !== "true") return;
            updatePosition();
            positionFrame = requestAnimationFrame(tick);
          };
          tick();
        }
        closeAllSubmenus();
        menuItems = Array.from(menu.querySelectorAll('[role="menuitem"]')).filter((item) => !item.hasAttribute("disabled") && item.getAttribute("aria-disabled") !== "true");
        if (menuItems.length > 0 && initialSelection) {
          if (initialSelection === "first") setActiveItem(0);
          if (initialSelection === "last") setActiveItem(menuItems.length - 1);
        }
      };
      trigger.addEventListener("click", () => {
        if (trigger.getAttribute("aria-expanded") === "true") closePopover();
        else openPopover(false);
      });
      dropdownMenuComponent.addEventListener("keydown", (event) => {
        const isExpanded = trigger.getAttribute("aria-expanded") === "true";
        if (event.key === "Escape") {
          if (isExpanded) closePopover();
          return;
        }
        if (!isExpanded) {
          if (["Enter", " "].includes(event.key)) {
            event.preventDefault();
            openPopover(false);
          } else if (event.key === "ArrowDown") {
            event.preventDefault();
            openPopover("first");
          } else if (event.key === "ArrowUp") {
            event.preventDefault();
            openPopover("last");
          }
          return;
        }
        if (menuItems.length === 0) return;
        let nextIndex = activeIndex;
        switch (event.key) {
          case "ArrowDown":
            event.preventDefault();
            nextIndex = activeIndex === -1 ? 0 : Math.min(activeIndex + 1, menuItems.length - 1);
            break;
          case "ArrowUp":
            event.preventDefault();
            nextIndex = activeIndex === -1 ? menuItems.length - 1 : Math.max(activeIndex - 1, 0);
            break;
          case "Home":
            event.preventDefault();
            nextIndex = 0;
            break;
          case "End":
            event.preventDefault();
            nextIndex = menuItems.length - 1;
            break;
          case "ArrowRight": {
            const item = menuItems[activeIndex];
            if (!item) break;
            const submenu = item.querySelector(':scope > [role="menu"]');
            if (submenu) {
              event.preventDefault();
              openSubmenu(item);
            }
            break;
          }
          case "ArrowLeft": {
            const item = menuItems[activeIndex];
            if (!item) break;
            const parentMenu = item.closest('[role="menu"]');
            if (parentMenu && parentMenu !== menu) {
              const parentItem = parentMenu.closest('[role="menuitem"][aria-haspopup="menu"]');
              if (parentItem) {
                event.preventDefault();
                parentItem.setAttribute("aria-expanded", "false");
                parentMenu.setAttribute("aria-hidden", "true");
              }
            }
            break;
          }
          case "Enter":
          case " ": {
            const item = menuItems[activeIndex];
            if (!item) return;
            const submenu = item.querySelector(':scope > [role="menu"]');
            event.preventDefault();
            if (submenu) openSubmenu(item);
            else closePopover();
            return;
          }
        }
        if (nextIndex !== activeIndex) {
          setActiveItem(nextIndex);
        }
      });
      menu.addEventListener("mousemove", (event) => {
        const item = event.target.closest('[role="menuitem"]');
        if (!item || !menuItems.includes(item)) return;
        const index = menuItems.indexOf(item);
        if (index !== activeIndex) setActiveItem(index);
        if (!isMobileLike() && item.getAttribute("aria-haspopup") === "menu") {
          openSubmenu(item);
        }
      });
      menu.addEventListener("mouseleave", () => {
        setActiveItem(-1);
      });
      menu.addEventListener("click", (event) => {
        const item = event.target.closest('[role="menuitem"]');
        if (!item) return;
        const submenu = item.querySelector(':scope > [role="menu"]');
        if (submenu) {
          event.preventDefault();
          if (item.getAttribute("aria-expanded") === "true") {
            item.setAttribute("aria-expanded", "false");
            submenu.setAttribute("aria-hidden", "true");
          } else {
            openSubmenu(item);
          }
          return;
        }
        closePopover();
      });
      document.addEventListener("click", (event) => {
        if (!dropdownMenuComponent.contains(event.target)) closePopover(false);
      });
      document.addEventListener("basecoat:popover", (event) => {
        if (event.detail.source !== dropdownMenuComponent) closePopover(false);
      });
      dropdownMenuComponent.dataset.dropdownMenuInitialized = true;
      dropdownMenuComponent.dispatchEvent(new CustomEvent("basecoat:initialized"));
    };
    if (window.basecoat) {
      window.basecoat.register("dropdown-menu", ".dropdown-menu:not([data-dropdown-menu-initialized])", initDropdownMenu);
    }
  })();

  // static/notebrew.js
  var initFunctions = {
    "data-click-event": function initClickEvent(targetElement, attributeValue) {
      targetElement.addEventListener("click", function dispatchEvent() {
        document.dispatchEvent(new Event(attributeValue));
      });
    },
    "data-go-back": function initGoBack(targetElement) {
      if (targetElement.tagName != "A") {
        return;
      }
      targetElement.addEventListener("click", function goBack(event) {
        if (!(event instanceof PointerEvent)) {
          return;
        }
        if (document.referrer && history.length > 2 && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();
          history.back();
        }
      });
    }
  };
  var attributeNames = Object.keys(initFunctions);
  function initialize(targetElement) {
    for (const attributeName of attributeNames) {
      if (targetElement.hasAttribute(attributeName) && !targetElement.hasAttribute(attributeName + "-initialized")) {
        try {
          initFunctions[attributeName](targetElement, targetElement.getAttribute(attributeName));
        } catch (e) {
          console.error(e);
        }
        targetElement.setAttribute(attributeName + "-initialized", "");
      }
    }
  }
  var selector = attributeNames.map((name) => "[" + name + "]").join(", ");
  for (const targetElement of document.querySelectorAll(selector)) {
    initialize(targetElement);
  }
  var observer = new MutationObserver(function(mutationRecords) {
    for (const mutationRecord of mutationRecords) {
      if (mutationRecord.type != "childList") {
        continue;
      }
      for (const addedElement of mutationRecord.addedNodes) {
        if (!(addedElement instanceof Element)) {
          continue;
        }
        initialize(addedElement);
        for (const targetElement of targetElement.querySelectorAll(selector)) {
          if (!(targetElement instanceof Element)) {
            continue;
          }
          initialize(targetElement);
        }
      }
    }
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
})();
